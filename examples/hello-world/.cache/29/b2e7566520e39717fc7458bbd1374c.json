{"id":"../node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Component.js","dependencies":[{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Component.js.map","includedInParent":true,"mtime":1538584912595},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/src/di/src/decorator/Component.ts","includedInParent":true,"mtime":1538584890728},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/package.json","includedInParent":true,"mtime":1538585011922},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/package.json","includedInParent":true,"mtime":1538575570092},{"name":"reflect-metadata","loc":{"line":3,"column":8},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Component.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/node_modules/reflect-metadata/Reflect.js"},{"name":"./Inject","loc":{"line":4,"column":25},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Component.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Inject.js"},{"name":"../ComponentReflector","loc":{"line":5,"column":37},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Component.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/ComponentReflector.js"},{"name":"../ApplicationContext","loc":{"line":6,"column":37},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Component.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/ApplicationContext.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"reflect-metadata\");\nconst Inject_1 = require(\"./Inject\");\nconst ComponentReflector_1 = require(\"../ComponentReflector\");\nconst ApplicationContext_1 = require(\"../ApplicationContext\");\nfunction registerBean(componentCtor, beanConfig) {\n    // @Inject decorators that may be defined inside of the class definition\n    // this @Component decorator is bound to, are processed first.\n    // This call collects it's meta data so the BeanFactory can\n    // handle the constructor parameter value injection correctly.\n    const parameterInjectionMetaData = Reflect.getOwnMetadata(Inject_1.INJECT_DECORATOR_METADATA_KEY, componentCtor, componentCtor.name);\n    ComponentReflector_1.ComponentReflector.register(componentCtor, parameterInjectionMetaData, beanConfig);\n    console.log('ComponentReflector registered', componentCtor, ComponentReflector_1.ComponentReflector.getSymbol(componentCtor));\n    // a generic intermediate class is conjured, inheriting the class\n    // the decorator is bound to. This keeps the prototype chain and later\n    // instanceof checks sane. It is necessary, because we want to\n    // *replace* the constructor with one that resolves it's arguments by itself (injection)\n    // and is capable of even handling @Inject decorators in it constructor arguments (wohoo)\n    const InjectionClassProxy = class extends componentCtor {\n        constructor(...args) {\n            super(...ApplicationContext_1.ApplicationContext.getInstance().resolveConstructorArguments(componentCtor));\n        }\n    };\n    ComponentReflector_1.ComponentReflector.registerDerived(componentCtor, InjectionClassProxy);\n    console.log('registered', InjectionClassProxy);\n    ApplicationContext_1.ApplicationContext.getInstance().setComponent(InjectionClassProxy);\n    // just replace the original class declaration by our generic one\n    return InjectionClassProxy;\n}\nfunction Component(beanConfigOrCtor) {\n    console.log('register Component', beanConfigOrCtor);\n    // called with @Component - no beanConfig object\n    if (!(typeof beanConfigOrCtor === 'function')) {\n        return (target) => {\n            return registerBean(target, beanConfigOrCtor);\n        };\n    }\n    else {\n        // called with @Component() or @Component({ ... })\n        return registerBean(beanConfigOrCtor);\n    }\n}\nexports.Component = Component;\n","map":{"version":3,"file":"Component.js","sourceRoot":"","sources":["../../../../src/di/src/decorator/Component.ts"],"names":[],"mappings":";;AAAA,4BAA0B;AAC1B,qCAGkB;AAClB,8DAAyD;AACzD,8DAAyD;AAYzD,SAAS,YAAY,CAA4B,aAAgB,EAAE,UAA0B;IAEzF,wEAAwE;IACxE,8DAA8D;IAC9D,2DAA2D;IAC3D,8DAA8D;IAC9D,MAAM,0BAA0B,GAA+B,OAAO,CAAC,cAAc,CACjF,sCAA6B,EAAE,aAAa,EAAE,aAAa,CAAC,IAAI,CACnE,CAAC;IAEF,uCAAkB,CAAC,QAAQ,CAAC,aAAa,EAAE,0BAA0B,EAAE,UAAU,CAAC,CAAC;IAEnF,OAAO,CAAC,GAAG,CAAC,+BAA+B,EAAE,aAAa,EAAE,uCAAkB,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;IAEzG,iEAAiE;IACjE,sEAAsE;IACtE,8DAA8D;IAC9D,wFAAwF;IACxF,yFAAyF;IACzF,MAAM,mBAAmB,GAAG,KAAM,SAAQ,aAAa;QACnD,YAAY,GAAG,IAAgB;YAC3B,KAAK,CAAC,GAAG,uCAAkB,CAAC,WAAW,EAAE,CAAC,2BAA2B,CAAC,aAAa,CAAC,CAAC,CAAC;QAC1F,CAAC;KACJ,CAAC;IAEF,uCAAkB,CAAC,eAAe,CAAC,aAAa,EAAE,mBAAmB,CAAC,CAAC;IAEvE,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,mBAAmB,CAAC,CAAC;IAE/C,uCAAkB,CAAC,WAAW,EAAE,CAAC,YAAY,CAAC,mBAAmB,CAAC,CAAC;IAEnE,iEAAiE;IACjE,OAAO,mBAAmB,CAAC;AAC/B,CAAC;AAED,SAAgB,SAAS,CAA4B,gBAAkC;IAEnF,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,gBAAgB,CAAC,CAAC;IAGpD,gDAAgD;IAChD,IAAI,CAAC,CAAC,OAAO,gBAAgB,KAAK,UAAU,CAAC,EAAE;QAE3C,OAAO,CAAC,MAAS,EAAE,EAAE;YACjB,OAAO,YAAY,CAAC,MAAM,EAAkB,gBAAgB,CAAC,CAAC;QAClE,CAAC,CAAA;KAEJ;SAAM;QAEH,kDAAkD;QAClD,OAAO,YAAY,CAAK,gBAAgB,CAAC,CAAC;KAC7C;AACL,CAAC;AAjBD,8BAiBC","sourcesContent":["import \"reflect-metadata\";\nimport {\n    INJECT_DECORATOR_METADATA_KEY,\n    ArgumentsInjectionMetaData,\n} from \"./Inject\";\nimport {ComponentReflector} from \"../ComponentReflector\";\nimport {ApplicationContext} from \"../ApplicationContext\";\n\nexport interface BeanConfig<T extends IComponent<any>> {\n\n    // reference to the component that should be used in test\n    mockedBy?: T;\n}\n\nexport interface IComponent<T> extends Function {\n    new(...args: any[]): T;\n}\n\nfunction registerBean<T extends IComponent<any>>(componentCtor: T, beanConfig?: BeanConfig<T>) {\n\n    // @Inject decorators that may be defined inside of the class definition\n    // this @Component decorator is bound to, are processed first.\n    // This call collects it's meta data so the BeanFactory can\n    // handle the constructor parameter value injection correctly.\n    const parameterInjectionMetaData: ArgumentsInjectionMetaData = Reflect.getOwnMetadata(\n        INJECT_DECORATOR_METADATA_KEY, componentCtor, componentCtor.name\n    );\n\n    ComponentReflector.register(componentCtor, parameterInjectionMetaData, beanConfig);\n\n    console.log('ComponentReflector registered', componentCtor, ComponentReflector.getSymbol(componentCtor));\n\n    // a generic intermediate class is conjured, inheriting the class\n    // the decorator is bound to. This keeps the prototype chain and later\n    // instanceof checks sane. It is necessary, because we want to\n    // *replace* the constructor with one that resolves it's arguments by itself (injection)\n    // and is capable of even handling @Inject decorators in it constructor arguments (wohoo)\n    const InjectionClassProxy = class extends componentCtor {\n        constructor(...args: Array<any>) {\n            super(...ApplicationContext.getInstance().resolveConstructorArguments(componentCtor));\n        }\n    };\n\n    ComponentReflector.registerDerived(componentCtor, InjectionClassProxy);\n\n    console.log('registered', InjectionClassProxy);\n\n    ApplicationContext.getInstance().setComponent(InjectionClassProxy);\n\n    // just replace the original class declaration by our generic one\n    return InjectionClassProxy;\n}\n\nexport function Component<T extends IComponent<any>>(beanConfigOrCtor?: BeanConfig<T>|T): T|any {\n\n    console.log('register Component', beanConfigOrCtor);\n\n\n    // called with @Component - no beanConfig object\n    if (!(typeof beanConfigOrCtor === 'function')) {\n\n        return (target: T) => {\n            return registerBean(target, <BeanConfig<T>> beanConfigOrCtor);\n        }\n\n    } else {\n\n        // called with @Component() or @Component({ ... })\n        return registerBean(<T> beanConfigOrCtor);\n    }\n}"]}},"hash":"2173f5b0f07473c1ac44d32b1c03832a","cacheData":{"env":{}}}