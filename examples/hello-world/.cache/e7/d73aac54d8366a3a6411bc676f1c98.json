{"id":"../node_modules/@springtype/springtype-incubator/dist/di/src/BeanFactory.js","dependencies":[{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/BeanFactory.js.map","includedInParent":true,"mtime":1538584912567},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/src/di/src/BeanFactory.ts","includedInParent":true,"mtime":1538584802331},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/package.json","includedInParent":true,"mtime":1538585011922},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/package.json","includedInParent":true,"mtime":1538575570092},{"name":"./decorator/Inject","loc":{"line":3,"column":25},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/BeanFactory.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Inject.js"},{"name":"./ComponentReflector","loc":{"line":4,"column":37},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/BeanFactory.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/ComponentReflector.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Inject_1 = require(\"./decorator/Inject\");\nconst ComponentReflector_1 = require(\"./ComponentReflector\");\nvar InjectionProfile;\n(function (InjectionProfile) {\n    InjectionProfile[\"DEFAULT\"] = \"DEFAULT\";\n    InjectionProfile[\"TEST\"] = \"TEST\";\n})(InjectionProfile = exports.InjectionProfile || (exports.InjectionProfile = {}));\nvar InjectionStrategy;\n(function (InjectionStrategy) {\n    InjectionStrategy[\"SINGLETON\"] = \"SINGLETON\";\n    InjectionStrategy[\"NEW\"] = \"NEW\";\n})(InjectionStrategy = exports.InjectionStrategy || (exports.InjectionStrategy = {}));\nclass BeanFactory {\n    constructor() {\n        this.registry = {};\n        this.singletonInstances = {};\n    }\n    setComponent(componentCtor) {\n        Reflect.set(this.registry, ComponentReflector_1.ComponentReflector.getSymbol(componentCtor), componentCtor);\n    }\n    getComponent(componentCtor) {\n        return Reflect.get(this.registry, ComponentReflector_1.ComponentReflector.getSymbol(componentCtor)) || null;\n    }\n    getBean(componentCtor, injectionProfile = InjectionProfile.DEFAULT, injectionStrategy = InjectionStrategy.SINGLETON) {\n        debugger;\n        // validate component reference\n        componentCtor = this.getComponent(componentCtor);\n        if (!ComponentReflector_1.ComponentReflector.isComponent(componentCtor)) {\n            return this.solveUnresolvableBean(componentCtor);\n        }\n        const classSymbol = ComponentReflector_1.ComponentReflector.getSymbol(componentCtor);\n        const beanConfig = ComponentReflector_1.ComponentReflector.getConfig(componentCtor);\n        if (injectionProfile === InjectionProfile.TEST &&\n            beanConfig &&\n            beanConfig.mockedBy &&\n            ComponentReflector_1.ComponentReflector.isComponent(beanConfig.mockedBy)) {\n            componentCtor = this.getComponent(beanConfig.mockedBy);\n            ComponentReflector_1.ComponentReflector.setIsMockComponent(componentCtor);\n        }\n        // only in case of singleton instance retrieval,\n        // try to fetch from cache, otherwise directly head to new instance creation\n        if (injectionStrategy === InjectionStrategy.SINGLETON) {\n            const singletonInstance = this.getSingletonBeanInstance(classSymbol);\n            if (singletonInstance) {\n                return singletonInstance;\n            }\n        }\n        // injectionStrategy === InjectionStrategy.NEW || singleton instance not found\n        const beanInstance = new componentCtor(...this.resolveConstructorArguments(componentCtor, injectionProfile));\n        if (injectionStrategy === InjectionStrategy.SINGLETON) {\n            this.setSingletonBeanInstance(classSymbol, beanInstance);\n        }\n        return beanInstance;\n    }\n    getSingletonBeanInstance(classSymbol) {\n        return Reflect.get(this.singletonInstances, classSymbol);\n    }\n    setSingletonBeanInstance(classSymbol, beanInstance) {\n        Reflect.set(this.singletonInstances, classSymbol, beanInstance);\n    }\n    resolveConstructorArguments(componentCtor, injectionProfile = InjectionProfile.DEFAULT) {\n        componentCtor = this.getComponent(componentCtor);\n        const isTestComponent = ComponentReflector_1.ComponentReflector.getIsMockComponent(componentCtor);\n        const cachedConstructorArguments = ComponentReflector_1.ComponentReflector.getResolvedConstructorArguments(componentCtor);\n        if (cachedConstructorArguments) {\n            return cachedConstructorArguments;\n        }\n        // fetch constructor parameter types from reflection metadata\n        const constructorParameterTypes = ComponentReflector_1.ComponentReflector.getConstructorArgumentTypes(componentCtor);\n        // and do the default round-trip to get all instances by type\n        const constructorArguments = this.getBeans(constructorParameterTypes, componentCtor, injectionProfile);\n        const constructorArgumentsParameterInjectionMetdata = ComponentReflector_1.ComponentReflector.getConstructorArgumentsInjectionMetadata(componentCtor);\n        // but if there are special @Inject decorations,\n        // we head to resolve them and use these values instead\n        if (constructorArgumentsParameterInjectionMetdata &&\n            constructorArgumentsParameterInjectionMetdata.arguments &&\n            constructorArgumentsParameterInjectionMetdata.arguments.length) {\n            const overrideInjectParamValues = constructorArgumentsParameterInjectionMetdata.arguments;\n            for (let i = 0; i < overrideInjectParamValues.length; i++) {\n                if (typeof overrideInjectParamValues[i] !== 'undefined') {\n                    constructorArguments[overrideInjectParamValues[i].index] =\n                        Inject_1.resolveInjectionParameterValue(constructorArgumentsParameterInjectionMetdata, overrideInjectParamValues[i].index, isTestComponent);\n                }\n            }\n        }\n        // cache\n        ComponentReflector_1.ComponentReflector.setResolvedConstructorArguments(componentCtor, constructorArguments);\n        return constructorArguments;\n    }\n    getBeans(types, forComponentCtor, injectionProfile = InjectionProfile.DEFAULT) {\n        if (types && types.length > 0) {\n            const beans = [];\n            types.forEach((_componentCtor) => {\n                const componentCtor = this.getComponent(_componentCtor);\n                console.log('componentCtor DOUNDKLNJSLKHUGfaeilzefa', componentCtor, _componentCtor);\n                // the component to inject (componentCtor) matches the component to inject in (forComponentCtor)\n                if (forComponentCtor === componentCtor) {\n                    beans.push(this.solveCyclicDependency(componentCtor));\n                }\n                else if (!componentCtor) {\n                    // bean unresolvable -> inject undefined\n                    beans.push(this.solveUnresolvableBean(_componentCtor));\n                }\n                else {\n                    const singletonBeanInstanceFromRegistry = this.getSingletonBeanInstance(ComponentReflector_1.ComponentReflector.getSymbol(componentCtor));\n                    if (singletonBeanInstanceFromRegistry) {\n                        beans.push(singletonBeanInstanceFromRegistry);\n                    }\n                    else {\n                        beans.push(\n                        // follow down the rabbit hole\n                        this.getBean(componentCtor, injectionProfile));\n                    }\n                }\n            });\n            return beans;\n        }\n        return [];\n    }\n    solveUnresolvableBean(componentCtor) {\n        console.warn(`The component referenced for injection is missing a @Component decorator: ${componentCtor.name}`);\n        return undefined;\n    }\n    solveCyclicDependency(componentCtor) {\n        console.warn(`Cyclic dependency detected in @Component: ${ComponentReflector_1.ComponentReflector.getName(componentCtor)}`);\n        return componentCtor;\n    }\n}\nexports.BeanFactory = BeanFactory;\n","map":{"version":3,"file":"BeanFactory.js","sourceRoot":"","sources":["../../../src/di/src/BeanFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import {IComponent} from \"./decorator/Component\";\nimport {ArgumentsInjectionMetaData, resolveInjectionParameterValue} from \"./decorator/Inject\";\nimport {ComponentReflector} from \"./ComponentReflector\";\n\nexport enum InjectionProfile {\n    DEFAULT = 'DEFAULT',\n    TEST = 'TEST',\n}\n\nexport enum InjectionStrategy {\n    SINGLETON = 'SINGLETON',\n    NEW = 'NEW'\n}\n\nexport class BeanFactory {\n\n    registry = {};\n    singletonInstances = {};\n\n    setComponent(componentCtor: IComponent<any>) {\n        Reflect.set(this.registry, ComponentReflector.getSymbol(componentCtor), componentCtor);\n    }\n\n    getComponent(componentCtor: IComponent<any>) {\n        return Reflect.get(this.registry, ComponentReflector.getSymbol(componentCtor)) || null;\n    }\n\n    getBean<T extends IComponent<any>>(\n        componentCtor: T,\n        injectionProfile: InjectionProfile = InjectionProfile.DEFAULT,\n        injectionStrategy: InjectionStrategy = InjectionStrategy.SINGLETON): any {\n\n        debugger;\n\n        // validate component reference\n        componentCtor = this.getComponent(componentCtor);\n\n        if (!ComponentReflector.isComponent(componentCtor)) {\n\n            return this.solveUnresolvableBean(\n                componentCtor\n            );\n        }\n\n        const classSymbol = ComponentReflector.getSymbol(componentCtor);\n        const beanConfig = ComponentReflector.getConfig(componentCtor);\n\n        if (injectionProfile === InjectionProfile.TEST &&\n            beanConfig &&\n            beanConfig.mockedBy &&\n            ComponentReflector.isComponent(beanConfig.mockedBy)) {\n\n            componentCtor = this.getComponent(beanConfig.mockedBy);\n\n            ComponentReflector.setIsMockComponent(componentCtor);\n        }\n\n        // only in case of singleton instance retrieval,\n        // try to fetch from cache, otherwise directly head to new instance creation\n        if (injectionStrategy === InjectionStrategy.SINGLETON) {\n\n            const singletonInstance = this.getSingletonBeanInstance(classSymbol);\n\n            if (singletonInstance) {\n                return singletonInstance;\n            }\n        }\n\n        // injectionStrategy === InjectionStrategy.NEW || singleton instance not found\n\n        const beanInstance = new componentCtor(\n            ...this.resolveConstructorArguments(componentCtor, injectionProfile)\n        );\n\n        if (injectionStrategy === InjectionStrategy.SINGLETON) {\n            this.setSingletonBeanInstance(classSymbol, beanInstance);\n        }\n        return beanInstance;\n    }\n\n    getSingletonBeanInstance(\n        classSymbol: symbol\n    ): any {\n        return Reflect.get(this.singletonInstances, classSymbol);\n    }\n\n    setSingletonBeanInstance(\n        classSymbol: symbol,\n        beanInstance: any\n    ): void {\n        Reflect.set(this.singletonInstances, classSymbol, beanInstance);\n    }\n\n    resolveConstructorArguments<T extends IComponent<any>>(\n        componentCtor: T,\n        injectionProfile: InjectionProfile = InjectionProfile.DEFAULT,\n    ): Array<any> {\n\n        componentCtor = this.getComponent(componentCtor);\n\n        const isTestComponent = ComponentReflector.getIsMockComponent(componentCtor);\n\n        const cachedConstructorArguments = ComponentReflector.getResolvedConstructorArguments(componentCtor);\n\n        if (cachedConstructorArguments) {\n            return cachedConstructorArguments;\n        }\n\n\n        // fetch constructor parameter types from reflection metadata\n        const constructorParameterTypes: Array<IComponent<any>> = ComponentReflector.getConstructorArgumentTypes(\n            componentCtor\n        );\n\n        // and do the default round-trip to get all instances by type\n        const constructorArguments = this.getBeans(\n            constructorParameterTypes,\n            componentCtor,\n            injectionProfile\n        );\n\n        const constructorArgumentsParameterInjectionMetdata: ArgumentsInjectionMetaData =\n            ComponentReflector.getConstructorArgumentsInjectionMetadata(componentCtor);\n\n        // but if there are special @Inject decorations,\n        // we head to resolve them and use these values instead\n        if (constructorArgumentsParameterInjectionMetdata &&\n            constructorArgumentsParameterInjectionMetdata.arguments &&\n            constructorArgumentsParameterInjectionMetdata.arguments.length) {\n\n            const overrideInjectParamValues = constructorArgumentsParameterInjectionMetdata.arguments;\n\n            for (let i = 0; i < overrideInjectParamValues.length; i++) {\n\n                if (typeof overrideInjectParamValues[i] !== 'undefined') {\n\n                    constructorArguments[overrideInjectParamValues[i].index] =\n\n                        resolveInjectionParameterValue(\n                            constructorArgumentsParameterInjectionMetdata,\n                            overrideInjectParamValues[i].index,\n                            isTestComponent\n                        );\n                }\n            }\n        }\n\n        // cache\n        ComponentReflector.setResolvedConstructorArguments(componentCtor, constructorArguments);\n\n        return constructorArguments;\n    }\n\n    getBeans<T extends IComponent<any>>(\n        types: Array<IComponent<any>>,\n        forComponentCtor: T,\n        injectionProfile: InjectionProfile = InjectionProfile.DEFAULT,\n    ): Array<IComponent<any>> {\n\n        if (types && types.length > 0) {\n\n            const beans: Array<any> = [];\n\n            types.forEach((_componentCtor: IComponent<any>) => {\n\n                const componentCtor = this.getComponent(_componentCtor);\n\n                console.log('componentCtor DOUNDKLNJSLKHUGfaeilzefa', componentCtor, _componentCtor);\n\n                // the component to inject (componentCtor) matches the component to inject in (forComponentCtor)\n                if (forComponentCtor === componentCtor) {\n\n                    beans.push(\n                        this.solveCyclicDependency(componentCtor)\n                    );\n                } else if (!componentCtor) {\n\n                    // bean unresolvable -> inject undefined\n                    beans.push(\n                        this.solveUnresolvableBean(\n                            _componentCtor\n                        )\n                    );\n\n                } else {\n\n                    const singletonBeanInstanceFromRegistry = this.getSingletonBeanInstance(\n                        ComponentReflector.getSymbol(componentCtor)\n                    );\n\n                    if (singletonBeanInstanceFromRegistry) {\n\n                        beans.push(singletonBeanInstanceFromRegistry)\n\n                    } else {\n\n                        beans.push(\n                            // follow down the rabbit hole\n                            this.getBean(componentCtor, injectionProfile)\n                        );\n                    }\n                }\n            });\n            return beans;\n        }\n        return [];\n    }\n\n    solveUnresolvableBean<T extends IComponent<any>>(\n        componentCtor: T\n    ): any {\n\n        console.warn(`The component referenced for injection is missing a @Component decorator: ${componentCtor.name}`);\n\n        return undefined;\n    }\n\n    solveCyclicDependency<T extends IComponent<any>>(componentCtor: T): T {\n\n        console.warn(`Cyclic dependency detected in @Component: ${ComponentReflector.getName(componentCtor)}`);\n\n        return componentCtor;\n    }\n}"]}},"hash":"c4abaec5c7f9acf486e4cdac7bce6e7c","cacheData":{"env":{}}}