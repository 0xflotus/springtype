{"id":"../node_modules/@springtype/springtype-incubator/dist/di/src/ComponentReflector.js","dependencies":[{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/ComponentReflector.js.map","includedInParent":true,"mtime":1538584912531},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/src/di/src/ComponentReflector.ts","includedInParent":true,"mtime":1538255645659},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/package.json","includedInParent":true,"mtime":1538585011922},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/package.json","includedInParent":true,"mtime":1538575570092},{"name":"./decorator/Inject","loc":{"line":3,"column":25},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/ComponentReflector.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Inject.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Inject_1 = require(\"./decorator/Inject\");\nexports.COMPONENT_SYMBOL = Symbol('COMPONENT_SYMBOL');\nexports.COMPONENT_CONSTRUCTOR_PARAMETER_METADATA = Symbol('COMPONENT_CONSTRUCTOR_PARAMETER_METADATA');\nexports.COMPONENT_NAME = Symbol('COMPONENT_NAME');\nexports.COMPONENT_CONFIG = Symbol('COMPONENT_CONFIG');\nexports.RESOLVED_CONSTRUCTOR_ARGUMENTS = Symbol('RESOLVED_CONSTRUCTOR_ARGUMENTS');\nexports.COMPONENT_IS_MOCK_FLAG = Symbol('COMPONENT_IS_MOCK_FLAG');\n/**\n * This class uses the Reflect.metadata standard API (polyfilled)\n * to fetch and store compile-time and runtime reflected metadata.\n *\n * Calls to Reflect.getMetadata() point to TypeScript compiler generated\n * metadata. All other Reflect.* calls deal with runtime metadata (from decorators, BeanFactory).\n */\nclass ComponentReflector {\n    static setIsMockComponent(componentCtor) {\n        Reflect.set(componentCtor, exports.COMPONENT_IS_MOCK_FLAG, true);\n    }\n    static getIsMockComponent(componentCtor) {\n        return !!Reflect.get(componentCtor, exports.COMPONENT_IS_MOCK_FLAG);\n    }\n    static getMethodArgumentTypes(componentCtor, propertyName) {\n        return Reflect.getMetadata('design:paramtypes', componentCtor, propertyName) || [];\n    }\n    static getConstructorArgumentTypes(componentCtor) {\n        return Reflect.getMetadata('design:paramtypes', componentCtor) || [];\n    }\n    static register(componentCtor, parameterInjectionMetadata, beanConfig) {\n        Reflect.set(componentCtor, exports.COMPONENT_CONFIG, beanConfig);\n        Reflect.set(componentCtor, exports.COMPONENT_SYMBOL, Symbol(componentCtor.name));\n        Reflect.set(componentCtor, exports.COMPONENT_NAME, componentCtor.name);\n        Reflect.set(componentCtor, exports.COMPONENT_CONSTRUCTOR_PARAMETER_METADATA, parameterInjectionMetadata);\n    }\n    static registerDerived(originalComponentCtor, derivedComponentCtor) {\n        Reflect.set(derivedComponentCtor, exports.COMPONENT_SYMBOL, ComponentReflector.getSymbol(originalComponentCtor));\n        Reflect.set(derivedComponentCtor, exports.COMPONENT_NAME, ComponentReflector.getName(originalComponentCtor));\n        Reflect.set(derivedComponentCtor, exports.COMPONENT_CONFIG, ComponentReflector.getConfig(originalComponentCtor));\n        Reflect.set(derivedComponentCtor, exports.COMPONENT_CONSTRUCTOR_PARAMETER_METADATA, ComponentReflector.getConstructorArgumentsInjectionMetadata(originalComponentCtor));\n    }\n    static getConstructorArgumentsInjectionMetadata(componentCtor) {\n        return Reflect.get(componentCtor, exports.COMPONENT_CONSTRUCTOR_PARAMETER_METADATA);\n    }\n    static setConstructorArgumentsInjectionMetadata(targetClassInstanceOrCtor, parameterIndex, injectionReference, injectionStrategy) {\n        // fetch (probably existing) meta data\n        const parameterInjectionMetaData = Reflect.getOwnMetadata(Inject_1.INJECT_DECORATOR_METADATA_KEY, targetClassInstanceOrCtor, targetClassInstanceOrCtor.name) || Inject_1.createDefaultArgumentsInjectionMetadata();\n        // enhance meta data for parameter\n        parameterInjectionMetaData.arguments[parameterIndex] = {\n            index: parameterIndex,\n            injectionReference,\n            injectionStrategy\n        };\n        // (re-)define injection reference meta data\n        Reflect.defineMetadata(Inject_1.INJECT_DECORATOR_METADATA_KEY, parameterInjectionMetaData, targetClassInstanceOrCtor, targetClassInstanceOrCtor.name);\n    }\n    static setMethodArgumentsInjectionMetadata(targetClassInstanceOrCtor, parameterIndex, propertyKey, injectionReference, injectionStrategy) {\n        // fetch (probably existing) meta data\n        const parameterInjectionMetaData = ComponentReflector.getMethodArgumentsInjectionMetadata(targetClassInstanceOrCtor, propertyKey) || Inject_1.createDefaultArgumentsInjectionMetadata();\n        // enhance meta data for parameter\n        parameterInjectionMetaData.arguments[parameterIndex] = {\n            index: parameterIndex,\n            injectionReference,\n            injectionStrategy\n        };\n        // (re-define) injection reference for parameter index\n        Reflect.defineMetadata(Inject_1.INJECT_DECORATOR_METADATA_KEY, parameterInjectionMetaData, targetClassInstanceOrCtor, propertyKey);\n    }\n    static getMethodArgumentsInjectionMetadata(targetClassInstanceOrCtor, propertyKey) {\n        return Reflect.getOwnMetadata(Inject_1.INJECT_DECORATOR_METADATA_KEY, targetClassInstanceOrCtor, propertyKey);\n    }\n    static getSymbol(targetCtor) {\n        return Reflect.get(targetCtor, exports.COMPONENT_SYMBOL);\n    }\n    static getName(targetCtor) {\n        return Reflect.get(targetCtor, exports.COMPONENT_NAME);\n    }\n    static getConfig(targetCtor) {\n        return Reflect.get(targetCtor, exports.COMPONENT_CONFIG);\n    }\n    /* When constructor arguments (injections) are resolved, the result is cached for later use */\n    static setResolvedConstructorArguments(targetCtor, constructorArguments) {\n        Reflect.set(targetCtor, exports.RESOLVED_CONSTRUCTOR_ARGUMENTS, constructorArguments);\n    }\n    static getResolvedConstructorArguments(targetCtor) {\n        return Reflect.get(targetCtor, exports.RESOLVED_CONSTRUCTOR_ARGUMENTS);\n    }\n    static isComponent(componentCtor) {\n        return !!ComponentReflector.getSymbol(componentCtor);\n    }\n}\nexports.ComponentReflector = ComponentReflector;\n","map":{"version":3,"file":"ComponentReflector.js","sourceRoot":"","sources":["../../../src/di/src/ComponentReflector.ts"],"names":[],"mappings":"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","sourcesContent":["import {BeanConfig, IComponent} from \"./decorator/Component\";\nimport {\n    createDefaultArgumentsInjectionMetadata,\n    INJECT_DECORATOR_METADATA_KEY, InjectionReference,\n    ArgumentsInjectionMetaData\n} from \"./decorator/Inject\";\nimport {InjectionStrategy} from \"./BeanFactory\";\n\nexport const COMPONENT_SYMBOL = Symbol('COMPONENT_SYMBOL');\nexport const COMPONENT_CONSTRUCTOR_PARAMETER_METADATA = Symbol('COMPONENT_CONSTRUCTOR_PARAMETER_METADATA');\nexport const COMPONENT_NAME = Symbol('COMPONENT_NAME');\nexport const COMPONENT_CONFIG = Symbol('COMPONENT_CONFIG');\nexport const RESOLVED_CONSTRUCTOR_ARGUMENTS = Symbol('RESOLVED_CONSTRUCTOR_ARGUMENTS');\nexport const COMPONENT_IS_MOCK_FLAG = Symbol('COMPONENT_IS_MOCK_FLAG');\n\n/**\n * This class uses the Reflect.metadata standard API (polyfilled)\n * to fetch and store compile-time and runtime reflected metadata.\n *\n * Calls to Reflect.getMetadata() point to TypeScript compiler generated\n * metadata. All other Reflect.* calls deal with runtime metadata (from decorators, BeanFactory).\n */\nexport class ComponentReflector {\n\n    static setIsMockComponent(componentCtor: IComponent<any>): void {\n        Reflect.set(componentCtor, COMPONENT_IS_MOCK_FLAG, true);\n    }\n\n    static getIsMockComponent(componentCtor: IComponent<any>): boolean {\n        return !!Reflect.get(componentCtor, COMPONENT_IS_MOCK_FLAG);\n    }\n\n    static getMethodArgumentTypes(componentCtor: IComponent<any>, propertyName: string) {\n        return Reflect.getMetadata('design:paramtypes', componentCtor, propertyName) || [];\n    }\n\n    static getConstructorArgumentTypes(componentCtor: IComponent<any>): Array<IComponent<any>> {\n        return Reflect.getMetadata('design:paramtypes', componentCtor) || [];\n    }\n\n    static register(\n        componentCtor: IComponent<any>,\n        parameterInjectionMetadata: ArgumentsInjectionMetaData,\n        beanConfig?: BeanConfig<IComponent<any>>,\n    ): void {\n\n        Reflect.set(componentCtor, COMPONENT_CONFIG, beanConfig);\n        Reflect.set(componentCtor, COMPONENT_SYMBOL, Symbol(componentCtor.name));\n        Reflect.set(componentCtor, COMPONENT_NAME, componentCtor.name);\n        Reflect.set(componentCtor, COMPONENT_CONSTRUCTOR_PARAMETER_METADATA, parameterInjectionMetadata);\n    }\n\n    static registerDerived(\n        originalComponentCtor: IComponent<any>,\n        derivedComponentCtor: IComponent<any>,\n    ) {\n\n        Reflect.set(derivedComponentCtor, COMPONENT_SYMBOL, ComponentReflector.getSymbol(originalComponentCtor));\n        Reflect.set(derivedComponentCtor, COMPONENT_NAME, ComponentReflector.getName(originalComponentCtor));\n        Reflect.set(derivedComponentCtor, COMPONENT_CONFIG, ComponentReflector.getConfig(originalComponentCtor));\n        Reflect.set(derivedComponentCtor, COMPONENT_CONSTRUCTOR_PARAMETER_METADATA,\n            ComponentReflector.getConstructorArgumentsInjectionMetadata(originalComponentCtor));\n    }\n\n    static getConstructorArgumentsInjectionMetadata(\n        componentCtor: IComponent<any>\n    ): ArgumentsInjectionMetaData {\n        return Reflect.get(componentCtor, COMPONENT_CONSTRUCTOR_PARAMETER_METADATA);\n    }\n\n    static setConstructorArgumentsInjectionMetadata(\n        targetClassInstanceOrCtor: Function,\n        parameterIndex: number,\n        injectionReference: InjectionReference,\n        injectionStrategy: InjectionStrategy): void {\n\n\n        // fetch (probably existing) meta data\n        const parameterInjectionMetaData: ArgumentsInjectionMetaData = Reflect.getOwnMetadata(\n            INJECT_DECORATOR_METADATA_KEY, targetClassInstanceOrCtor, targetClassInstanceOrCtor.name\n        ) || createDefaultArgumentsInjectionMetadata();\n\n        // enhance meta data for parameter\n        parameterInjectionMetaData.arguments[parameterIndex] = {\n            index: parameterIndex,\n            injectionReference,\n            injectionStrategy\n        };\n\n        // (re-)define injection reference meta data\n        Reflect.defineMetadata(\n            INJECT_DECORATOR_METADATA_KEY,\n            parameterInjectionMetaData,\n            targetClassInstanceOrCtor,\n            targetClassInstanceOrCtor.name);\n    }\n\n    static setMethodArgumentsInjectionMetadata(\n        targetClassInstanceOrCtor: Object,\n        parameterIndex: number,\n        propertyKey: string | symbol,\n        injectionReference: InjectionReference,\n        injectionStrategy: InjectionStrategy\n    ): void {\n\n        // fetch (probably existing) meta data\n        const parameterInjectionMetaData: ArgumentsInjectionMetaData = ComponentReflector.getMethodArgumentsInjectionMetadata(\n            targetClassInstanceOrCtor, propertyKey\n        ) || createDefaultArgumentsInjectionMetadata();\n\n        // enhance meta data for parameter\n        parameterInjectionMetaData.arguments[parameterIndex] = {\n            index: parameterIndex,\n            injectionReference,\n            injectionStrategy\n        };\n\n        // (re-define) injection reference for parameter index\n        Reflect.defineMetadata(INJECT_DECORATOR_METADATA_KEY, parameterInjectionMetaData, targetClassInstanceOrCtor, propertyKey);\n    }\n\n    static getMethodArgumentsInjectionMetadata(\n        targetClassInstanceOrCtor: Object,\n        propertyKey: string | symbol,\n    ): ArgumentsInjectionMetaData {\n        return Reflect.getOwnMetadata(\n            INJECT_DECORATOR_METADATA_KEY, targetClassInstanceOrCtor, propertyKey\n        );\n    }\n\n    static getSymbol(targetCtor: IComponent<any>): symbol {\n        return Reflect.get(targetCtor, COMPONENT_SYMBOL);\n    }\n\n    static getName(targetCtor: IComponent<any>): string {\n        return Reflect.get(targetCtor, COMPONENT_NAME);\n    }\n\n    static getConfig(targetCtor: IComponent<any>): BeanConfig<IComponent<any>> {\n        return Reflect.get(targetCtor, COMPONENT_CONFIG);\n    }\n\n    /* When constructor arguments (injections) are resolved, the result is cached for later use */\n    static setResolvedConstructorArguments(targetCtor: IComponent<any>, constructorArguments: Array<IComponent<any>>): void {\n        Reflect.set(targetCtor, RESOLVED_CONSTRUCTOR_ARGUMENTS, constructorArguments);\n    }\n\n    static getResolvedConstructorArguments(targetCtor: IComponent<any>): Array<IComponent<any>> {\n        return Reflect.get(targetCtor, RESOLVED_CONSTRUCTOR_ARGUMENTS);\n    }\n\n    static isComponent(componentCtor: IComponent<any>): boolean {\n        return !!ComponentReflector.getSymbol(componentCtor);\n    }\n}"]}},"hash":"6ccb8ec6e350e2962bd42182d70ade1d","cacheData":{"env":{}}}