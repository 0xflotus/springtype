{"id":"../node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Autowired.js","dependencies":[{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Autowired.js.map","includedInParent":true,"mtime":1538584912604},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/src/di/src/decorator/Autowired.ts","includedInParent":true,"mtime":1538575734518},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/package.json","includedInParent":true,"mtime":1538585011922},{"name":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/package.json","includedInParent":true,"mtime":1538575570092},{"name":"./Inject","loc":{"line":3,"column":25},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Autowired.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Inject.js"},{"name":"../BeanFactory","loc":{"line":4,"column":30},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Autowired.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/BeanFactory.js"},{"name":"../ComponentReflector","loc":{"line":5,"column":37},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Autowired.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/ComponentReflector.js"},{"name":"../ApplicationContext","loc":{"line":6,"column":37},"parent":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/decorator/Autowired.js","resolved":"/Users/aron/IdeaProjects/springtype-incubator/examples/hello-world/node_modules/@springtype/springtype-incubator/dist/di/src/ApplicationContext.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Inject_1 = require(\"./Inject\");\nconst BeanFactory_1 = require(\"../BeanFactory\");\nconst ComponentReflector_1 = require(\"../ComponentReflector\");\nconst ApplicationContext_1 = require(\"../ApplicationContext\");\nfunction Autowired(target, propertyName, descriptor) {\n    const methodArgumentTypes = ComponentReflector_1.ComponentReflector.getMethodArgumentTypes(target, propertyName);\n    // backup original method\n    const method = descriptor.value;\n    // we replace the method again, the call the original impl. with injected arguments\n    descriptor.value = function () {\n        const cmp = ApplicationContext_1.ApplicationContext.getInstance().getComponent(target.constructor);\n        if (!cmp) {\n            throw new Error('@Autowired on methods requires @Component on the class.');\n        }\n        const isTestComponent = ComponentReflector_1.ComponentReflector.getIsMockComponent(cmp);\n        // replacement method impl. -> this is called when the actual @BeanMethod annotated method is called (hook)\n        const argumentsInjectionMetaData = ComponentReflector_1.ComponentReflector.getMethodArgumentsInjectionMetadata(target, propertyName);\n        const newArgs = [];\n        // 1. Copy initial argument values (non-optionals, default values)\n        for (let i = 0; i < arguments.length; i++) {\n            newArgs[i] = arguments[i];\n        }\n        // 2. There might be @Inject(...) decorations, process them and inject\n        if (argumentsInjectionMetaData &&\n            argumentsInjectionMetaData.arguments &&\n            argumentsInjectionMetaData.arguments.length) {\n            // copy arguments over into new arguments array (because arguments are immutable in modern times ;)\n            for (let i = 0; i < argumentsInjectionMetaData.arguments.length; i++) {\n                // resolve override injection argument\n                const injectionValue = Inject_1.resolveInjectionParameterValue(argumentsInjectionMetaData, i, isTestComponent);\n                // conditionally overwrite original call argument for sub-call\n                if (typeof injectionValue !== 'undefined') {\n                    newArgs[i] = injectionValue;\n                }\n                else if (argumentsInjectionMetaData.arguments[i]) {\n                    // parameter has @Inject() decorator, but no explicit value; fallback to default strategy\n                    if (methodArgumentTypes[i]) {\n                        // fetch singleton from cache by reflected type\n                        newArgs[i] = ApplicationContext_1.ApplicationContext.getInstance().getBean(methodArgumentTypes[i], isTestComponent ? BeanFactory_1.InjectionProfile.TEST : BeanFactory_1.InjectionProfile.DEFAULT, argumentsInjectionMetaData.arguments[i].injectionStrategy);\n                    }\n                }\n            }\n        }\n        // 3. For all arguments that are appended optional and are not passed and not injects by @Inject(...)\n        //    try to inject them using their type reference\n        for (let i = arguments.length; i < methodArgumentTypes.length; i++) {\n            if (typeof newArgs[i] === 'undefined' &&\n                ComponentReflector_1.ComponentReflector.isComponent(methodArgumentTypes[i])) {\n                newArgs[i] = ApplicationContext_1.ApplicationContext.getInstance().getBean(methodArgumentTypes[i], isTestComponent ? BeanFactory_1.InjectionProfile.TEST : BeanFactory_1.InjectionProfile.DEFAULT);\n            }\n        }\n        return method.apply(this, newArgs);\n    };\n}\nexports.Autowired = Autowired;\n","map":{"version":3,"file":"Autowired.js","sourceRoot":"","sources":["../../../../src/di/src/decorator/Autowired.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    ArgumentsInjectionMetaData, resolveInjectionParameterValue\n} from \"./Inject\";\nimport {InjectionProfile} from \"../BeanFactory\";\nimport {ComponentReflector} from \"../ComponentReflector\";\nimport {ApplicationContext} from \"../ApplicationContext\";\n\nexport function Autowired(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function | any>) {\n\n    const methodArgumentTypes = ComponentReflector.getMethodArgumentTypes(target, propertyName);\n\n    // backup original method\n    const method: Function = <Function> descriptor.value;\n\n    // we replace the method again, the call the original impl. with injected arguments\n    descriptor.value = function() {\n\n        const cmp = ApplicationContext.getInstance().getComponent(target.constructor);\n\n        if (!cmp) {\n            throw new Error('@Autowired on methods requires @Component on the class.');\n        }\n\n        const isTestComponent = ComponentReflector.getIsMockComponent(\n            cmp\n        );\n\n        // replacement method impl. -> this is called when the actual @BeanMethod annotated method is called (hook)\n        const argumentsInjectionMetaData: ArgumentsInjectionMetaData =\n            ComponentReflector.getMethodArgumentsInjectionMetadata(\n                target, propertyName\n            );\n\n        const newArgs = [];\n\n        // 1. Copy initial argument values (non-optionals, default values)\n        for (let i=0; i<arguments.length; i++) {\n            newArgs[i] = arguments[i];\n        }\n\n        // 2. There might be @Inject(...) decorations, process them and inject\n        if (argumentsInjectionMetaData &&\n            argumentsInjectionMetaData.arguments &&\n            argumentsInjectionMetaData.arguments.length) {\n\n            // copy arguments over into new arguments array (because arguments are immutable in modern times ;)\n            for (let i=0; i<argumentsInjectionMetaData.arguments.length; i++) {\n\n                // resolve override injection argument\n                const injectionValue = resolveInjectionParameterValue(argumentsInjectionMetaData, i, isTestComponent);\n\n                // conditionally overwrite original call argument for sub-call\n                if (typeof injectionValue !== 'undefined') {\n\n                    newArgs[i] = injectionValue;\n\n                } else if (argumentsInjectionMetaData.arguments[i]) {\n\n                    // parameter has @Inject() decorator, but no explicit value; fallback to default strategy\n                    if (methodArgumentTypes[i]) {\n\n                        // fetch singleton from cache by reflected type\n                        newArgs[i] = ApplicationContext.getInstance().getBean(\n                            methodArgumentTypes[i],\n                            isTestComponent ? InjectionProfile.TEST : InjectionProfile.DEFAULT,\n                            argumentsInjectionMetaData.arguments[i].injectionStrategy\n                        );\n                    }\n                }\n            }\n        }\n\n        // 3. For all arguments that are appended optional and are not passed and not injects by @Inject(...)\n        //    try to inject them using their type reference\n        for (let i=arguments.length; i<methodArgumentTypes.length; i++) {\n\n            if (typeof newArgs[i] === 'undefined' &&\n                ComponentReflector.isComponent(methodArgumentTypes[i])) {\n\n\n                newArgs[i] = ApplicationContext.getInstance().getBean(\n                    methodArgumentTypes[i],\n                    isTestComponent ? InjectionProfile.TEST : InjectionProfile.DEFAULT\n                );\n            }\n        }\n        return method.apply(this, newArgs);\n    }\n}"]}},"hash":"affef60c4325e3ed25a49be523f85fd1","cacheData":{"env":{}}}